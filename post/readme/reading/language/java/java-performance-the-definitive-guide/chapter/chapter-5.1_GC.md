# 垃圾收集
```md
垃圾回收的性能由以下基本操作决定：
1. 找到不再使用的对象
2. 回收它们使用的内存
3. 对堆的内存布局进行压缩整理

完成这些操作时，不同的收集器采取了不同的方法，也就表现出了不同的性能特征。
```

* stop the world
```md
GC 回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。
这一点在 移动对象时特别重要：
对象的内存地址会发生变化，因此在这个过程中任何应用程序线程都不应该再访问该对象。
所有应用线程停止运行产生的停顿被称为 时空停顿 （stop the world）。

通常这些停顿对性能的影响最大，GC调优时，应尽量减少这种停顿是最为关键的考量因素。
```

## 分代垃圾收集器
* 代 （Generation）
```md
“老年代”（Old Generation 或 Tenured Generation）

“新生代”（Young Generation）
新生代划分为： Eden 空间 和 Survivor 空间。
```

* 分代机制的原因
```md
很多对象的生命周期很短。
```
```java
sum = new BigDecimal(0);
for (StockPrice sp : prices.values()) {
        BigDecimal diff = sp.getClosingPrice().subtract(averagePrice);
        diff = diff.multiply(diff);
        sum = sum.add(diff);
}
```
```md
BigDecimal 是不可变对象，以上这个简单的循环处理一年的股票数据（大约250个循环），
会创建 750 个 BigDecimal 对象，这些对象会在循环的下一个周期开始时被丢弃。
在 add() 方法内，JDK 的库方法 会创建更多类似 BigDecimal 的中间对象。
最终，在一小段代码中，有大量的对象被快速创建和丢弃。
```
```md
Java 中，上述操作是非常普遍的，所以GC的设计就特别需要考虑处理大量（有时候是大多数）的临时对象。
这也是分代设计的初衷之一。
```
* Minor GC
```md
新生代是堆的一部分，对象首先在新生代中分配，当新生代填满时，GC 会暂停所有的应用程序，回收新生代空间。
不在使用的对象会被回收，仍在使用的对象会被移动到其他地方，这种操作被称为“Minor GC”。

* 两个性能上的优势
1. 与处理整个堆相比，只处理新生代更快，意味着更少的停顿时间。
  不过这也意味着应用程序会更频繁的发生停顿，因为JVM 不再等到整个堆填满再GC。
  停顿的次数 和 停顿时间的长短，实际上是一种权衡。
2. 源于新生代中对象的分配方式，对象分配与Eden空间（占据新生代绝大对数）。
  GC 时，Eden 空间的存活对象要么被移动到 Survivor 空间，要么移动到老年代。
  由于所有的对象都被移走，相当于新生代空间自动地做了一次压缩整理。
```
> 所有的GC算法在对 新生代 进行垃圾回收时 都在存在 “stop the world” 现象。

* Full GC
```md
最终老年代也会填满，JVM 需要找出老年代不在使用的对象，并回收。
而是垃圾回收算法差异最大的地方。

简单的垃圾回收算法，直接停掉所有的应用线程，找出不再使用的对象，进行回收。
接着对堆空间进行整理，这个过程被称为“Full GC”。
这通常导致 应用程序长时间的停顿。
```

* Concurrent 垃圾收集器
```md
通过更复杂的计算，还可以再运行线程的同时找出不在使用的对象。CMS 和 G1 收集器 采用这种方式。
由于不停止应用程序，所以被称为“Concurrent 垃圾收集器”。

同时由于它们将停止应用程序的可能降到最小，也被称为“低停顿（Low-Pause）收集器，
有时也称为 无停顿收集器（虽然不太贴切）”。

Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。

CMS 和 G1 收集器停顿更少，更短，但其代价是消耗更多的CPU。
实际上也可能遭遇长时间的 Full GC 停顿（尽量避免这种停顿，是这些GC的调优算法要考虑的重要方面）
```

* 评估 垃圾收集器
```md
考虑需要达到的整体性能目标。每一个决定都需要权衡取舍。

如果对单个请求的响应时间有要求（如 Java 企业级服务器），你应该考虑一下因素：
* 单个请求会受到停顿时间的影响，受Full GC 的影响会更大。
  如果目标是尽可能缩短响应时间，那么 选择 Concurrent 垃圾收集器 更能合适。
* 如果平均响应时间比最大响应时间更重要（如 90%的响应时间）
  通常采用 Thoughtout 收集器就能满足需求。
* 使用 Concurrent 垃圾收集器 减少停顿的同时，会消耗额外的CPU。

为批量应用选择垃圾回收器可以遵循以下原则：
* 如果 CPU 足够强劲，选择 Concurrent 垃圾收集器 减少 Full GC 产生的停顿。
* 如果 CPU 有限，那么 Concurrent 垃圾收集器 的CPU 消耗会让批量任务消耗更多的时间。
```
## GC 算法
* Serial 垃圾收集器
```md

```
* Throughtput 垃圾收集器
```md

```
* CMS 收集器
```md

```
* G1 垃圾收集器
```md

```
## 选择 GC 算法
* GC 算法 及 批量子任务
```md

```
* GC 算法 和 吞吐测试
```md

```
* GC 算法 及 响应时间测试
```md

```
* CMS 和 G1 的抉择
```md

```







