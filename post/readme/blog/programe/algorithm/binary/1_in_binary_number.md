# 二进制数中1的个数
> by sunnnychan@outlook.com

## 问题
```md
求一个整数二进制表示中1的个数。
```
## 分析
```md
这是一道比较常见的算法面试题，最近听 吴军 老师讲述这个问题，才对这个问题有了一个新的理解。
一个小的问题，却能包含了很多的思考问题的思路。
```
## 实现
* 遍历
> 思路
```md
最容易想到的是对二进制数按位遍历，判断每一个位置上是否为1，然后计数。
二进制数判断一个位置上是否为1，做与运算即可。

先回顾下移位操作
移位操作 区分为 左移 和 右移。
左移操作，高位舍弃，低位填充0。左移对于有符号数和无符号数的操作是一致的。
而 右移 是低位舍弃，高位做填充，根据高位填充的内容不同分为：
算术右移 ：使用符号位填充移位后高位的空位。
逻辑右移 ：或叫无符号右移，没有算术含义，它用0填充高位。

很容易想到有两种方案：
1. 将待查二进制数移位
每次都判断最低位的值，完成后右移一位，直到该数为0。
注意：右移之后高位填充的必须是0。
所以上述的算法应该使用无符号右移，因为采用算法右移时，负数高位填充的是1。

你可能会想到，可以使用左移，因为左移是一致的，然后判断高位。
不同机器整型数的存储位数是不一样的，所以最高位所在的位置也会有差别，你必须考虑算法实现的可移植性。

上述算法还有一个副作用，对原有的数据做了修改。
那么我们可以对和待查数据做与操作的操作数移位。

2. 构造与操作数
思路基本一致，从 00 ... 01 开始，不断左移，然后与待查数据做与操作。
好处是使用左移，不需要考虑正负数，也不用考虑机器的字长。
从细节来看，方法1（右移将待查二进制数）与操作的次数 和最高位一位的1的位置有关系。
方法2（左移构造与操作数）必须判断所有位数（具体看整型占用的存储字节数）。
```
* 消去最低一位的1
```md
网上常见的优化方案，思路是 将待查整数减1得到的结果与原待查数做 与操作。

借助了二进制的计算特性：
如果数据位从左按照0起始编号，假设待查数最低一位的1的位置是n，
减一之后得到的数与原来的数在0-n 位置上的取值是相反的，做与运算之后等于把最低一位的1变成了0，
最后重复上述操作，每做一次，1的个数加1，最终得到1的个数。

我们重点思考下这个算法优化的思路：
回归到问题本身，求解的是找到1的个数，在移位遍历方法中，我们做了一些无效的0的比较。
所以，这是我们优化的方向，在 消去最低一位的1 算法中，每次找出来的就是有效的1，
算法最终的比较次数就是 二进制序列中实际出现的1的个数。

注意：上述特性只对 正整数有效（负数的情况做一个预处理）。
总结：以上算法思路比较特别，使用了二进制计算的特性，在解决很多二进制问题时，可以使用这个思路。
```
* Hash表查找
```md
利用空间来换时间的话，可以有更高效的解决方案。
32位计算机能表示的数的范围是确定的，而每个数的二进制表示中1的个数也是确定的，
可以构造一个Hash表，这样对于任意一个数的查询效率是O(1)。

32位无符号数表示的范围 是 0 到 2的32次方 -1，也就是2的32次方个数，
最大一个数的1个数是32，所以需要最少 6bit的空间来存储1的个数的值。
整个Hash表的存储大小为 2的32次方 * 6 bit，是3G的空间，
如果语言不支持位结构，那可能需要按照 1字节来存储，就是 4G 空间。
如果是8G内存的机器，内存的一半就需要被占用。

32位机器上Hash表在单台机器上可以实现。
如果是64位机，所需的内存资源是单机完全没有办法满足的，甚至做集群都没法搞定。

有没有方法可以再 查询效率 和 存储空间之间做一个权衡？
```
* 折中方案
```md
把待查数据做一个拆分，将一个32位数据，拆分为两个 16位数，
而16位数构建的Hash表之战64K（2的16次方 * 1字节 = 2的6次方K = 64K）空间。
当然需要查询两次，把两次的结果相加得到最终的结果。

类似的还可以继续拆分为4个八位数，再对8位数进行建表，只需要256个字节。
此时需要查表4次。

这样本来 无法实现的 64位数也就可以实现了。
而且可以根据实际的需求场景来权衡查询性能和存储成本。
```

> 一次Hash的方案 总是比 拆分的折中方案 快？
```md
直观上看 一次 查询，比多次查询肯定会快。
有这样的结论，是因为你的潜意识给这个场景设置了一个前提，就是所有的查询都发生在内存。

当前的计算机系统都是二级缓存架构，通常我们会考虑内存和磁盘这一级的存储效率的差距。
CPU的缓存我们很少考虑，如果考虑这层缓存，那么上述的问题就不一定了。

一次Hash需要4G空间，这些数据不可能全部加载进CPU缓存(一般M级别大小)，
如果数据没有加载到CPU缓存，就需要先从内存加载。
折中方案的存储要小得多，完全可以一次加载进CPU缓存。
而查多次CPU缓存也比查一次内存要快一个量级。
```

## 总结
> 最后把吴军老师的总结摘抄如下：
```md
1.对于一个技术问题，可以有纯技术的解法，对应的就是采用“与操作”解决方式，
也可以有直观便于理解的方法，对应的就是Hash表查找。
前者在数学上漂亮，但是难于理解，后者好理解，但是需要付出一定的空间成本。

2.空间和时间有时候会有一定的冲突，为了时间有时候需要牺牲空间。
但并非空间越多效果就越好。

3.因此，计算机的解决方案通常是一个系统性的优化问题，单纯一个部分的改进可能会引起另一个部分的问题。
上述缓存的容量成为一个不可逾越的边界，当表的大小超过这个界限时，继续增加只会带来副作用。

4.这样看似简单的问题，背后的道理并不简单。可以有很多的思考。
```



